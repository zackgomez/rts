#include "NetPlayer.h"
#include "Game.h"
#include "PlayerAction.h"
#include "util.h"

namespace rts {

NetPlayer::NetPlayer(id_t playerID, id_t teamID, const std::string &name,
    const glm::vec3 &color, NetConnection *conn)
  : Player(playerID, teamID, name, color),
    connection_(conn),
    doneTick_(-1e6),
    localPlayerID_(-1) {
  assert(connection_);
  logger_ = Logger::getLogger("NetPlayer");
}

NetPlayer::~NetPlayer() {
  connection_->stop();
  delete connection_;
}

bool NetPlayer::update(tick_t tick) {
  std::unique_lock<std::mutex> lock(connection_->getMutex());
  std::queue<PlayerAction> &actions = connection_->getQueue();

  // If thread has died, then we're done
  if (!connection_->running()) {
    PlayerAction a;
    a["type"] = ActionTypes::LEAVE_GAME;
    a["pid"] = toJson(playerID_);
    game_->addAction(playerID_, a);
    // We're done with the entire game, including this tick
    return true;
  }

  // Read as many actions as were queued
  while (!actions.empty()) {
    PlayerAction a = actions.front();
    actions.pop();

    invariant(
      toID(a["pid"]) == playerID_ || a["type"] == ActionTypes::LEAVE_GAME,
      "bad action from network thread");
    game_->addAction(playerID_, a);

    // if we get a none, then we're done with another frame... make it so
    if (a["type"] == ActionTypes::DONE) {
      invariant(a["tick"].asInt64() > doneTick_, "bad tick in action");
      doneTick_ = (int64_t) a["tick"].asInt64();
    }

    // Messages generated by the net thread don't know our pid, fill it in
    if (!a.isMember("pid")) {
      a["pid"] = toJson(playerID_);
    }
  }

  // Have we received all the messages for this tick?
  return doneTick_ >= tick;
}

void NetPlayer::playerAction(id_t playerID, const PlayerAction &action) {
  // Ignore our own messages
  if (playerID == playerID_) {
    return;
  }

  // Only send messages relating to the local player(s?) on this machine
  if (playerID == localPlayerID_) {
    connection_->sendPacket(action);
  }

  // If the action was a leave game, close down thread
  if (action["type"] == ActionTypes::LEAVE_GAME) {
    connection_->stop();
  }
}
};  // rts
