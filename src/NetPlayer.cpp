#include "NetPlayer.h"
#include "Game.h"
#include "PlayerAction.h"

net_msg readPacket(kissnet::tcp_socket_ptr sock)
    throw(kissnet::socket_exception)
{
    net_msg ret;

    int bytes_read;
    // First read header
    if ((bytes_read = sock->recv((char *)&ret.sz, 4)) < 4)
    {
        if (bytes_read == 0)
            throw kissnet::socket_exception("client disconnected gracefully");

        Logger::getLogger("readPacket")->fatal() << "Read " << bytes_read
            << " as header.\n";
        assert(false && "Didn't read a full 4 byte header");
    }

    // TODO(zack) don't assume byte order is the same

    // Then allocate and read payload
    ret.msg = std::string(ret.sz, '\0');
    if (sock->recv(&ret.msg[0], ret.sz) < ret.sz)
        assert(false && "Didn't read a full message");

    return ret;
}

void netThreadFunc(kissnet::tcp_socket_ptr sock, std::queue<PlayerAction> &queue,
        std::mutex &queueMutex, bool &running)
{
    LoggerPtr logger = Logger::getLogger("NetThread");
    Json::Reader reader;
    while (running)
    {
        // Each loop, push exactly one message onto queue
        PlayerAction act;
        try
        {
            net_msg packet = readPacket(sock);

            // Parse
            reader.parse(packet.msg, act);

            //logger->debug() << "Received action: " << act << '\n';

        }
        catch (kissnet::socket_exception e)
        {
            logger->error() << "Caught socket exception '" << e.what() 
                << "'... terminating thread.\n";
            // On exception, leave game
            act["type"] = ActionTypes::LEAVE_GAME;
            running = false;
        }

        // Lock and queue
        std::unique_lock<std::mutex> lock(queueMutex);
        queue.push(act);
        // automatically unlocks when lock goes out of scope
    }

    logger->info() << "Thread finished\n";
}

NetPlayer::NetPlayer(int64_t playerID, kissnet::tcp_socket_ptr sock) :
    Player(playerID),
    sock_(sock),
    running_(true),
    doneTick_(-1e6),
    localPlayerID_(-1)
{
    logger_ = Logger::getLogger("NetPlayer");
    netThread_ = std::thread(netThreadFunc, sock_, std::ref(actions_),
            std::ref(mutex_), std::ref(running_));
}

NetPlayer::~NetPlayer()
{
    running_ = false;
    // TODO(zack) interrupt the other thread if possible
    netThread_.join();
}

bool NetPlayer::update(int64_t tick)
{
    std::unique_lock<std::mutex> lock(mutex_);
    // Read as many actions as were queued
    while (!actions_.empty())
    {
        PlayerAction a = actions_.front();
        actions_.pop();

        assert(a["pid"].asInt64() == playerID_ || a["type"] == ActionTypes::LEAVE_GAME);
        game_->addAction(playerID_, a);

        // if we get a none, then we're done with another frame... make it so
        if (a["type"] == ActionTypes::DONE)
        {
            assert(a["tick"].asInt64() > doneTick_);
            doneTick_ = (int64_t) a["tick"].asInt64();
        }

        // Messages generated by the net thread don't know our pid, fill it in
        if (!a.isMember("pid"))
            a["pid"] = toJson(playerID_);
    }

    // Have we received all the messages for this tick?
    return doneTick_ >= tick;
}

void NetPlayer::playerAction(int64_t playerID, const PlayerAction &action)
{
    // Ignore our own messages
    if (playerID == playerID_)
        return;

    // Only send messages relating to the local player(s?) on this machine
    if (playerID == localPlayerID_)
    {
        std::string body = writer_.write(action);
        uint32_t len = body.size();
        // TODO(zack) endianness issue here?
        std::string msg((char *) &len, 4);
        msg.append(body);

        // Just send out the message
        sock_->send(msg);
    }

    // If the action was a leave game, close down thread
    if (action["type"] == ActionTypes::LEAVE_GAME)
        running_ = false;
}
